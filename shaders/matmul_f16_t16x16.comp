#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uint M, N, K, lda, ldb, ldc;
} pc;

// SSBOs use float16_t elements (smaller bandwidth)
layout(std430, binding = 0) readonly buffer ABuf { float16_t A[]; };
layout(std430, binding = 1) readonly buffer BBuf { float16_t B[]; };
layout(std430, binding = 2) writeonly buffer CBuf { float16_t C[]; };

const uint TILE = 16;
shared float16_t Asub[TILE][TILE];
shared float16_t Bsub[TILE][TILE];

void main() {
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;
    if (row >= pc.M || col >= pc.N) return;

    float acc = 0.0;

    for (uint kt = 0; kt < pc.K; kt += TILE) {
        uint a_col = kt + gl_LocalInvocationID.x;
        uint b_row = kt + gl_LocalInvocationID.y;

        float16_t a_val = (a_col < pc.K) ? A[row * pc.lda + a_col] : float16_t(0.0);
        float16_t b_val = (b_row < pc.K) ? B[b_row * pc.ldb + col] : float16_t(0.0);

        Asub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = a_val;
        Bsub[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = b_val;
        barrier();

        #pragma unroll
        for (uint k = 0; k < TILE; ++k) {
            acc += float(Asub[gl_LocalInvocationID.y][k]) * float(Bsub[k][gl_LocalInvocationID.x]);
        }

        barrier();
    }

    C[row * pc.ldc + col] = float16_t(acc);
}
