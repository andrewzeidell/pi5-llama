#version 450
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uint rows;
    uint cols;
} pc;

layout(std430, binding = 0) buffer XBuf { float X[]; };

// Compute rowwise softmax for matrix X[rows][cols]
shared float row_max;
shared float row_sum;

void main() {
    uint row = gl_GlobalInvocationID.x;
    if (row >= pc.rows) return;

    // Step 1: find max
    row_max = -3.402823e38; // -FLT_MAX
    barrier();

    for (uint j = gl_LocalInvocationIndex; j < pc.cols; j += gl_WorkGroupSize.x) {
        float v = X[row * pc.cols + j];
        atomicMax((uint*)(&row_max), floatBitsToUint(v));
    }
    barrier();

    float maxv = row_max;
    row_sum = 0.0;
    barrier();

    // Step 2: exp and accumulate sum
    for (uint j = gl_LocalInvocationIndex; j < pc.cols; j += gl_WorkGroupSize.x) {
        float v = X[row * pc.cols + j];
        float ev = exp(v - maxv);
        X[row * pc.cols + j] = ev;
        atomicAdd((uint*)(&row_sum), floatBitsToUint(ev));
    }
    barrier();

    float sumv = row_sum;
    // Step 3: normalize
    for (uint j = gl_LocalInvocationIndex; j < pc.cols; j += gl_WorkGroupSize.x) {
        X[row * pc.cols + j] /= sumv;
    }
}
