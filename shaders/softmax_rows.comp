#version 450
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform Push {
    uint rows;
    uint cols;
} pc;

layout(std430, binding = 0) buffer XBuf { float X[]; };

const uint WG = 64;
shared float s_red[WG];

void main() {
    uint row = gl_GlobalInvocationID.x;
    if (row >= pc.rows) return;

    uint lid = gl_LocalInvocationIndex;

    // 1) Per-thread local max over strided elements
    float m = -3.402823e38; // -FLT_MAX
    for (uint j = lid; j < pc.cols; j += WG) {
        float v = X[row * pc.cols + j];
        m = max(m, v);
    }
    s_red[lid] = m;
    barrier();

    // Reduce to row max in s_red[0]
    for (uint offset = WG >> 1; offset > 0; offset >>= 1) {
        if (lid < offset) {
            s_red[lid] = max(s_red[lid], s_red[lid + offset]);
        }
        barrier();
    }
    float maxv = s_red[0];
    barrier();

    // 2) Exponentiate (in place) and accumulate partial sum
    float psum = 0.0;
    for (uint j = lid; j < pc.cols; j += WG) {
        float ev = exp(X[row * pc.cols + j] - maxv);
        X[row * pc.cols + j] = ev;
        psum += ev;
    }
    s_red[lid] = psum;
    barrier();

    // Reduce to total sum in s_red[0]
    for (uint offset = WG >> 1; offset > 0; offset >>= 1) {
        if (lid < offset) {
            s_red[lid] += s_red[lid + offset];
        }
        barrier();
    }
    float invsum = 1.0 / s_red[0];
    barrier();

    // 3) Normalize
    for (uint j = lid; j < pc.cols; j += WG) {
        X[row * pc.cols + j] *= invsum;
    }
}
